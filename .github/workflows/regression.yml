name: Parallel Jobs per File (ops + uat with env)

on:
  workflow_dispatch:

jobs:
  generate-chunks:
    runs-on: ubuntu-latest
    outputs:
      chunks: ${{ steps.set.outputs.chunks }}
    steps:
      - uses: actions/checkout@v4

      - id: set
        run: |
          shopt -s nullglob
          files=(tests/cmr/l2ss-py/ops/* tests/cmr/l2ss-py/uat/*)
          total=${#files[@]}
          chunks=5
          chunk_size=$(( (total + chunks - 1) / chunks ))
          chunk_size=2  # force for testing

          declare -A chunks_map

          for i in $(seq 0 $((chunks-1))); do
            start=$((i * chunk_size))
            chunk=("${files[@]:start:chunk_size}")
            json=$(printf '%s\n' "${chunk[@]}" \
              | jq -R 'split("/") | {env: .[-2], file: .[-1]}' \
              | jq -s '{include: .}')
            chunks_map["chunk$((i+1))"]="$json"
          done

          all=$(printf '%s\n' "${!chunks_map[@]}" \
            | jq -R . \
            | jq -s --argjson c "$(printf '%s\n' "${chunks_map[@]}" | jq -s .)" '
                reduce range(0; length) as $i ({}; .[.[ $i ]] = $c[$i])')

          echo "chunks<<EOF" >> "$GITHUB_OUTPUT"
          echo "$all" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

  process-chunks:
    needs: generate-chunks
    runs-on: ubuntu-latest
    strategy:
      matrix:
        chunk-name: [chunk1, chunk2, chunk3, chunk4, chunk5]
      fail-fast: false
    env:
      CMR_USER: ${{ secrets.CMR_USER }}
      CMR_PASS: ${{ secrets.CMR_PASS }}
    steps:
      - name: Extract matrix data
        id: extract
        run: |
          echo '${{ needs.generate-chunks.outputs.chunks }}' > chunks.json
          jq -c ".${{ matrix.chunk-name }}.include[]" chunks.json > items.json
          echo "items<<EOF" >> "$GITHUB_OUTPUT"
          cat items.json >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Run matrixed tests
        uses: actions/github-script@v7
        with:
          script: |
            const items = JSON.parse(process.env.items);
            console.log("Running tests for", items.length, "items");
            for (const { env, file } of items) {
              console.log(`Testing env=${env}, file=${file}`);
            }

      - name: Checkout repository
        uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.10"

      - name: Install Poetry
        uses: abatilo/actions-poetry@v3
        with:
          poetry-version: 2.1.3

      - name: Poetry Install
        run: poetry install

      - name: Run Regression
        working-directory: tests
        run: |
          echo '${{ steps.extract.outputs.items }}' | jq -c '.[]' | while read -r entry; do
            env=$(echo "$entry" | jq -r '.env')
            file=$(echo "$entry" | jq -r '.file')
            echo "Running pytest for env=$env file=$file"
            poetry run pytest verify_collection.py --env "$env" --concept_id "$file"
          done
